{"posts":[{"title":"PlayWright自动化","text":"介绍Playwright Test 是专门为了满足端到端测试的需求而创建的。 Playwright 支持所有现代渲染引擎，包括 Chromium、WebKit 和 Firefox。 在 Windows、Linux 和 macOS 上进行本地或 CI 测试，无头测试或使用适用于 Android 和 Mobile Safari 的 Google Chrome 的原生移动模拟进行测试。 使用向导安装 Pyenv虚拟环境安装: pyenv的安装与使用 进入项目中并创建一个虚拟环境 12pyenv virtualenv 3.11.1 pw-demopyenv local pw-demo pip安装环境依赖 123pip install pytest-playwright pytest# 安装完毕后，安装PlayWright驱动playwright install 验证 12playwright --version# Version 1.41.0 Demo运行test_example.py 1234567891011121314151617import refrom playwright.sync_api import Page, expectdef test_has_title(page: Page): page.goto(&quot;https://playwright.dev/&quot;) # Expect a title &quot;to contain&quot; a substring. expect(page).to_have_title(re.compile(&quot;Playwright&quot;))def test_get_started_link(page: Page): page.goto(&quot;https://playwright.dev/&quot;) # Click the get started link. page.get_by_role(&quot;link&quot;, name=&quot;Get started&quot;).click() # Expects page to have a heading with the name of Installation. expect(page.get_by_role(&quot;heading&quot;, name=&quot;Installation&quot;)).to_be_visible() Pytest驱动运行前提条件: 测试文件防止在目录tests/下 测试文件和函数必须以test_开头 基本命令行自动遍历终端当前目录下所有以test_开头的py文件并执行 1pytest 指定目录下执行 1pyest tests/ 指定文件执行 1pytest tests/test_demo.py 指定文件里的函数执行 1pytest tests/test_demo::test_function_1 pytest-playwright插件相关headed指定以headless=False模式开始测试，即显示浏览器页面。(headless=True则无页面无感知测试) 1pytest --headed 如果你的driver不是通过conftest传入的，则不生效 在test函数里定义了broswer并执行pytest --headed，headed参数不生效 1234567891011from playwright.async_api import async_playwright@pytest.mark.asyncioasync def test_demo(): async with async_playwright() as p: b = await p.chromium.launch() page = await b.new_page() await page.goto(&quot;https://www.baidu.com&quot;) await page.screenshot(path=&quot;baidu.png&quot;) await b.close() 通过fixture传入page实例并执行pytest --headed，headed参数生效 123456789from playwright.async_api import async_playwright, Page@pytest.mark.asyncioasync def test_demo(page: Page): async with async_playwright() as p: b = await p.chromium.launch() await page.goto(&quot;https://webclient-test.flyele.vip/board/month-view&quot;) await page.screenshot(path=&quot;baidu.png&quot;) await b.close() 具体实现代码参考pytest_playwright.py line127 12345678910111213141516@pytest.fixture(scope=&quot;session&quot;)def browser_type_launch_args(pytestconfig: Any) -&gt; Dict: launch_options = {} headed_option = pytestconfig.getoption(&quot;--headed&quot;) if headed_option: launch_options[&quot;headless&quot;] = False elif VSCODE_PYTHON_EXTENSION_ID in sys.argv[0] and _is_debugger_attached(): # When the VSCode debugger is attached, then launch the browser headed by default launch_options[&quot;headless&quot;] = False browser_channel_option = pytestconfig.getoption(&quot;--browser-channel&quot;) if browser_channel_option: launch_options[&quot;channel&quot;] = browser_channel_option slowmo_option = pytestconfig.getoption(&quot;--slowmo&quot;) if slowmo_option: launch_options[&quot;slow_mo&quot;] = slowmo_option return launch_options","link":"/2024/01/23/PlayWright%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"title":"SVG免费资源","text":"分享几个SVG免费资源网站 SVG Repo网址：https://www.svgrepo.com/提供大量的免费 SVG 图标和图形，可以按分类浏览和搜索。 FontAwesome网址：https://fontawesome.com/FontAwesome 提供了一些免费的 SVG 图标，可以在其网站上浏览和下载。 Flaticon网址：https://www.flaticon.com/提供了大量的矢量图标，你可以免费下载，并提供不同尺寸和格式的图标。 SVG Backgrounds网址：https://www.svgbackgrounds.com/专注于提供各种 SVG 背景图案，可以用于网页设计等。 Undraw网址：https://undraw.co/illustrations提供了一系列现代风格的插图，可以用于各种项目，所有插图都是免费的。 SVGOMG网址：https://jakearchibald.github.io/svgomg/SVGOMG 是一个在线的 SVG 优化工具，你可以在这里上传 SVG 文件并进行优化，然后下载。 Heroicons网址：https://heroicons.com/提供了一系列简单且现代的 SVG 图标，适用于 Web 开发项目。 Open Peeps网址：https://www.openpeeps.com/提供了一组可爱的人物插图，可以免费使用。","link":"/2023/12/26/SVG%E5%85%8D%E8%B4%B9%E8%B5%84%E6%BA%90/"},{"title":"API接口测试","text":"对于API接口测试的扫盲。包含多种协议。 常见协议介绍API测试中，常见的协议包含HTTP、HTTPS、WebSocket、WebSockets、TCP、UDP、gRPC、SOAP、Dubbo/HSF。这些协议是用于在应用程序之间进行通信和数据传输的标准。根据具体的应用场景和需求，测试人员可以选择适合的协议进行测试。 HTTP\\HTTPS","link":"/2024/01/25/API%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"},{"title":"搭建hexo和githubPage","text":"简介​ 本文章介绍如何使用Hexo + GithubPage + EasyImage(图床)去搭建一个个人的博客站。 环境安装Node安装(NVM版本)​ hexo依赖于Node运行的，所以我们需要系统安装Node和NPM去执行代码。如果已经安装了可以跳过当前文章，从Hexo配置开始。而本次需要安装的是NVM。NVM（Node Version Manager）是Node.js的版本管理器，可以让我们轻松地在不同的Node.js版本之间进行切换。 MacM1版本安装 安装brew(已安装可跳过) 12# brew国内克隆镜像/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot; ​ 运行后会自动安装brew脚本 安装nvm 1brew install nvm 创建.nvm目录(已存在可跳过) 1mkdir ~/.nvm 编辑 /.zshrc或/.zprofile 配置文件 1234# zshrc(二选一)vim ~/.zshrc# zprofile(二选一)vim ~/.zprofile 在 ~/.zshrc 配置文件内添加内容 123export NVM_DIR=&quot;$HOME/.nvm&quot; [ -s &quot;/opt/homebrew/opt/nvm/nvm.sh&quot; ] &amp;&amp; . &quot;/opt/homebrew/opt/nvm/nvm.sh&quot; # This loads nvm [ -s &quot;/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm&quot; ] &amp;&amp; . &quot;/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm&quot; # This loads nvm bash_completion :wq保存退出，使用 source 命令使配置生效 123# 根据自己的编辑来source .zprofile或.zshrcsource ~/.zshrcsource ~/.zprofile 查看配置是否生效 12echo $NVM_DIR/Users/your-username/.nvm //打印出这个就说明成功了 愉快的使用nvm吧 1234nvm install 14.6.0nvm use 14.6.0nvm listnvm uninstall 14.6.0 Ubuntu安装 确保apt镜像源为国内源，防止下载失败，参考Ubuntu更换apt源 安装nvm 1234567# 截止2023年12月29日，nvm最新版本为0.39.7。可访问https://github.com/nvm-sh/nvm?tab=readme-ov-file#installing-and-updating查看最新版本# curl或wget二选一curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bashwget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash 编辑 /.bashrc或/.bash_profile 配置文件 123# 添加以下内容export NVM_DIR=&quot;$([ -z &quot;${XDG_CONFIG_HOME-}&quot; ] &amp;&amp; printf %s &quot;${HOME}/.nvm&quot; || printf %s &quot;${XDG_CONFIG_HOME}/nvm&quot;)&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm :wq保存退出，使用 source 命令使配置生效 123# 根据自己的编辑来source .bashrc或.bash_profilesource ~/.bashrcsource ~/.bash_profile 查看配置是否生效 12echo $NVM_DIR/Users/your-username/.nvm #打印出这个就说明成功了 Windows安装参考https://github.com/coreybutler/nvm-windows Hexo配置安装npm运行命令等待安装完成 1npm install -g hexo-cli 初始化创建和初始化博客目录 123456# 创建mkdir myblog# 进入cd myblog# 初始化hexo init 主题安装安装主题hexo-theme-icarus，参考地址: https://github.com/ppoffice/hexo-theme-icarus 1234# 进入myblog目录下cd myblog# npm安装主题npm install hexo-theme-icarus 通过编辑_config.yml应用主题 1theme: icarus 通过命令行编辑主题 1hexo config theme icarus GithubPage与Hexo的联动Github仓库GithubPage仓库GithubPage仓库是Github默认的一个个人页仓库，当你创建出一个以你username + .github.io的仓库时，会默认初始化仓库并将你的静态页面内容展示在https://${username}.github.io/ 访问Github并登录，创建一个仓库${usernmae}.github.io其中username为你账号名，可以参考其他仓库的前缀。 仓库必须设为Public。 ​ 备份仓库创建一个私人仓库用于备份hexo配置以及文章，方便后续可快速迁移部署 访问Github并登录，创建一个仓库用于存储你的hexo文章以及配置 仓库可公开也可以私人 Hexo Deploy与GithubPage仓库关联hexo支持使用hexo deploy的指令自动将当前hexo目录文章以github page支持的格式进行推送并展示。 我们需要去_config.yml中配置相关的信息。 如果没有配置git的话参考文章Github配置 123456# vim _config.ymldeploy: type: git # 可以是ssh方式或者https方式，根据自己的git配置进行 repo: git@github:${user_name}/${user_name}.github.io.git branch: master 备份仓库与git仓库关联1git remote add origin git@any-hexo-repository 测试12hexo new &quot;新文章&quot;hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy 图床配置当使用hexo进行博客编写时，一般使用图床的方式的图片进行处理。用默认的话总是难以配置以及管理。 这里是使用了EasyImage + Ubuntu + Docker的服务器进行的。 部署EasyImage12345678910111213141516# EasyImage docker-compose.yamlversion: '3.3'services: easyimage: image: ddsderek/easyimage:latest container_name: easyimage ports: - '9001:80' # 这里修改端口映射 environment: - TZ=Asia/Shanghai - PUID=1000 - PGID=1000 volumes: - '/root/data/docker_data/easyimage/config:/app/web/config' - '/root/data/docker_data/easyimage/i:/app/web/i' restart: unless-stopped 配置EasyImage 访问EasyImage, 服务器地址:9001 完成首次引导配置 进入设置 -&gt; 图床安全 -&gt; 开始登录上传(安全) 进入设置 -&gt; 图床安全 -&gt; 开启API上传 获取上传API 进入设置 -&gt; API设置 获取API调用地址和有效Token Typora与EasyImage API联动 上传脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243# 在script目录创建脚本，my_blog/script/easy_image_typora_upload.sh#!/bin/bashAPI_URL=&quot;${EasyImage API地址}&quot;TOKEN=&quot;${EasyImage 有效TOken}&quot;# 检查是否传入了至少一个文件路径if [ $# -eq 0 ]; then echo &quot;No images specified.&quot; exit 1fi# 初始化空的 URLs 数组declare -a URLs# 遍历所有的图片路径参数for IMAGE_PATH in &quot;$@&quot;; do # 使用 curl 上传图片并捕获响应 RESPONSE=$(curl --request POST \\ --url $API_URL \\ --header 'content-type: multipart/form-data' \\ --form token=$TOKEN \\ --form image=@&quot;$IMAGE_PATH&quot; 2&gt;/dev/null) # 使用 Python 解析 JSON 响应并提取 URL echo &quot;$RESPONSE&quot; URL=$(python3 -c &quot;import sys, json; print(json.loads(sys.argv[1])['url'])&quot; &quot;$RESPONSE&quot;) # 将 URL 添加到数组中 URLs+=(&quot;$URL&quot;)done# 检查是否有 URL 被收集if [ ${#URLs[@]} -gt 0 ]; then # 打印成功消息和所有的 URL echo &quot;Upload Success:&quot; for URL in &quot;${URLs[@]}&quot;; do echo &quot;$URL&quot; doneelse echo &quot;Upload failed for all images.&quot; exit 1fi 进入typora设置 -&gt; 图像 -&gt; 插入图片时 -&gt; 上传图片 -&gt; 命令 -&gt; ${上传脚本的完整路径} 验证图片上传选项 Hexo脚本设置创建Hexo的博文配置编辑_config.yaml12# _config.ymlnew_post_name: ':year/:month/:day/:title/index.md' 使用脚本创建1234567891011121314151617181920212223242526272829303132# post.shconst fs = require('fs')const path = require('path')const moment = require('moment')const { exec } = require('child_process')const readline = require('readline')const title = process.argv[2]const date = moment().format('YYYY/MM/DD')const postDir = path.join(__dirname, 'source/_posts', date, title)fs.mkdirSync(postDir, { recursive: true })const postFile = path.join(postDir, 'index.md')const content = `---title: ${title}date: ${moment().format('YYYY-MM-DD HH:mm:ss')}tags: []categories: [&quot;程序日常&quot;]cover: &quot;&quot;toc: false---This is the content of my post.&lt;!-- more --&gt;`// 写入文件fs.writeFileSync(postFile, content)// 在终端输出创建的路径console.log(`Created new post at: ${postFile}`) 测试1node post.js 这是文章的开头 hexo-theme-icarus 定制设置目录粘性定位原来只支持侧边栏整体粘性定位，为了阅读体验，只针对目录开启粘性定位，增加 column-left is-sticky 类，并调整样式。 12345diff:source/js/main.js if ($toc.length &gt; 0) {+ $toc.addClass('column-left is-sticky'); const $mask = $('&lt;div&gt;'); 1234diff:include/style/article.styl+#toc+ max-height: calc(100vh - 22px)+ overflow-y: scroll","link":"/2023/12/26/%E6%90%AD%E5%BB%BAhexo%E5%92%8CgithubPage/"},{"title":"Python的魔法函数","text":"在Python中，魔法函数（也称为特殊方法）是类中以双下划线（__）开头和结尾的方法。它们有时被称为“双下方法”（dunder methods）。这些特殊的方法被Python的解释器用于实现和提供语言的内置行为。 常见的魔法函数例如，当你添加两个对象时，解释器实际上会调用对象的魔法函数 __add__。 这些方法通常不需要直接调用，而是由Python的某些语句或操作隐式触发。例如，当你执行 len(obj) 时，实际上调用的是 obj.__len__() 方法。 下面是一些常见的魔法函数及其用途： __init__(self, ...): 对象初始化方法，在创建新实例后被调用。 __del__(self): 对象的析构方法，当对象被销毁时调用。 __repr__(self): 官方字符串表示，用于调试和日志记录，通常应该是明确的并且尽可能返回一个表示如何创建该对象的字符串。 __str__(self): 用户友好的字符串表示，用于 print() 函数和 str() 内置函数。 __call__(self, ...): 使实例能够像函数一样被调用。 __getattr__(self, name): 在访问不存在的属性时调用。 __setattr__(self, name, value): 尝试设置属性时调用。 __delattr__(self, name): 尝试删除属性时调用。 __getitem__(self, key): 使用索引操作符时调用。 __setitem__(self, key, value): 为索引操作符赋值时调用。 __delitem__(self, key): 删除索引操作符时调用。 __iter__(self): 返回迭代器对象，用于迭代容器。 __next__(self): 获取迭代器的下一个项目。 __add__(self, other): 加法操作符。 __sub__(self, other): 减法操作符。 __mul__(self, other): 乘法操作符。 __truediv__(self, other): 真除法操作符。 __floordiv__(self, other): 地板除法操作符。 __mod__(self, other): 取模操作符。 __pow__(self, other[, modulo]): 幂运算操作符。 __eq__(self, other): 等于操作符。 __ne__(self, other): 不等于操作符。 __lt__(self, other): 小于操作符。 __le__(self, other): 小于等于操作符。 __gt__(self, other): 大于操作符。 __ge__(self, other): 大于等于操作符。 这些魔法函数使得Python的对象可以模拟内置类型的行为，提供了一种非常强大和灵活的方式来定义类。通过实现这些特殊方法，开发者可以定制对象的行为，使它们更加直观和易于使用。 __repr__和__str____两个方法都是用于定义类对象表示的方法。常用于调用print和str方法时的返回值显示。 以下是几种 __repr__和__str__不同定义情况的展示方法: 自定义类没有实现 __repr__和__str__方法时 使用print和str会调用父类object中的两个方法，并返回类名 + 内存地址。 123456789class Person: def __init__(self, name: str, age: int): self.name = name self.age = age nick = Person(&quot;nick&quot;, 20)print(nick) # &lt;__main__.Person object at 0x107750bd0&gt;print(str(nick)) # '&lt;__main__.Person object at 0x107750bd0&gt;' 自定义类只实现了 __repr__ 使用print和str会调用 __repr__返回值 1234567891011class Person: def __init__(self, name: str, age: int): self.name = name self.age = age def __repr__(self): return f&quot;Person(name={self.name}, age={self.age})&quot; nick = Person(&quot;nick&quot;, 20)print(nick) # Person(name=nick, age=20)print(str(nick)) # 'Person(name=nick, age=20)' 自定义类只实现了__str__ 使用print和str会调用__str__返回值，如果直接使用解释器则返回父类object类的repr方法，并返回类名 + 内存地址 123456789101112class Person: def __init__(self, name: str, age: int): self.name = name self.age = age def __str__(self): return f&quot;Person(name={self.name}, age={self.age})&quot; nick = Person(&quot;nick&quot;, 20)print(nick) # Person(name=nick, age=20)print(str(nick)) # 'Person(name=nick, age=20)'nick # &lt;__main__.Person at 0x1076f82d0&gt; 自定类同时实现了 __repr__ 和 __str__ 如果类同时实现了 __repr__ 和 __str__，那么 print(obj) 和 str(obj) 会使用 __str__ 的返回值，而在需要使用 repr(obj) 的地方，比如直接在解释器中输入对象名，将会使用 __repr__ 的返回值 1234567891011121314151617class Person: def __init__(self, name: str, age: int): self.name = name self.age = age def __repr__(self): return f&quot;Person(name={self.name}, age={self.age})&quot; def __str__(self): return f&quot;{self.name} is {self.age} year old&quot; nick = Person(&quot;nick&quot;, 20)nick # Person(name=nick, age=20)print(nick) # nick is 20 year oldstr(nick) # nick is 20 year oldrepr(nick) # Person(name=nick, age=20) 比较操作符自定义类需要进行比较时，可以通过__ge__等方法来实现类的比较。 比如定义一个Person类实例化并比较它们. 12345678910class Person: def __init__(self, name: str, age: int): self.name = name self.age = age john = Person(&quot;john&quot;, 18)nick = Person(&quot;nick&quot;, 20)print(john &gt; nick) # TypeError: '&gt;' not supported between instances of 'Person' and 'Person' 为这个类添加比较操作符魔法函数，并以年龄大小作为比较 1234567891011121314class Person: def __init__(self, name: str, age: int): self.name = name self.age = age def __lt__(self, other): print(&quot;小于操作符&quot;) return self.age &lt; other.age john = Person(&quot;john&quot;, 18)nick = Person(&quot;nick&quot;, 20)print(john &gt; nick) # 小于操作符, False 这样就为我们的自定义类实现了类的比较。","link":"/2024/01/03/Python%E7%9A%84%E9%AD%94%E6%B3%95%E5%87%BD%E6%95%B0/"},{"title":"PlayWright自动化","text":"This is the content of my post.","link":"/2024/01/10/PlayWright%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"title":"Ubuntu更换apt源","text":"​ 国内用户在使用基于 Debian 的 Linux 发行版（如 Ubuntu）时，通常建议更换 APT（Advanced Package Tool）软件源到国内的镜像。否则在使用apt进行更新时较慢。 ​ apt镜像源存储路径一般存在于/etc/apt/sources.list，建议在修改先备份好原来的sources.list以防万一出现问题可以快速恢复。 1234# 进入apt sources.list路径cd /etc/apt# 备份cp sources.list sources.list.bak ​ 当你完成源的更新后，需要执行一下命令去更新软件包索引(必须)和升级(可选)。 1234# 更新软件包索引(必须)sudo apt update# 升级软件包(可选)sudo apt upgrade ​ 以下则是Ubuntu几个长期稳定版本的apt国内镜像源，采用的是清华源。可参考网站https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/以获取最新的咨询 Ubuntu 22.04 LTS 1234567891011121314# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiversedeb http://security.ubuntu.com/ubuntu/ jammy-security main restricted universe multiverse# deb-src http://security.ubuntu.com/ubuntu/ jammy-security main restricted universe multiverse# 预发布软件源，不建议启用# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse# # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse Ubuntu 20.04 LTS 1234567891011121314# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiversedeb http://security.ubuntu.com/ubuntu/ focal-security main restricted universe multiverse# deb-src http://security.ubuntu.com/ubuntu/ focal-security main restricted universe multiverse# 预发布软件源，不建议启用# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse# # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse Ubuntu 18.04 LTS 1234567891011121314# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb http://security.ubuntu.com/ubuntu/ bionic-security main restricted universe multiverse# deb-src http://security.ubuntu.com/ubuntu/ bionic-security main restricted universe multiverse# 预发布软件源，不建议启用# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse# # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse Ubuntu 16.04 LTS 1234567891011121314# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiversedeb http://security.ubuntu.com/ubuntu/ xenial-security main restricted universe multiverse# deb-src http://security.ubuntu.com/ubuntu/ xenial-security main restricted universe multiverse# 预发布软件源，不建议启用# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse# # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse","link":"/2023/12/29/Ubuntu%E6%9B%B4%E6%8D%A2apt%E6%BA%90/"},{"title":"React中后台管理平台","text":"基于antd5 + vite + zustand开发一个React中后台管理平台模版库 环境安装环境依赖安装yarn1npm install --global yarn vite创建react项目1234yarn create vite# 输入项目名# 选择React# 选择TypeScript 安装React依赖12yarn add @ant-design/pro-components antd zustand axios react-router-domyarn add -D @types/node prettier 项目配置 进入目录并删除src目录下所有文件 src下创建main.tsx 12345678910import { App } from 'antd'import React from 'react'import ReactDOM from 'react-dom/client'ReactDOM.createRoot(document.getElementById('root')!).render( &lt;React.StrictMode&gt; &lt;App /&gt; &lt;/React.StrictMode&gt;,) src下创建App.tsx 12345678910function App() { return ( &lt;&gt; &lt;div&gt;demo&lt;/div&gt; &lt;/&gt; )}export default App 编辑vite.config.ts并添加resolve值 1234567891011121314import { defineConfig } from 'vite'import react from '@vitejs/plugin-react'import path from &quot;path&quot;// https://vitejs.dev/config/export default defineConfig({ plugins: [react()], resolve: { alias: { &quot;@&quot;: path.resolve(__dirname, './src'), } },}) 编辑tsconfig.json并添加以下的值 12345678910111213{ &quot;compilerOptions&quot;: { ..., &quot;allowJs&quot;: true, &quot;strict&quot;: false, &quot;baseUrl&quot;: &quot;.&quot;, &quot;paths&quot;: { &quot;@/*&quot;: [ &quot;src/*&quot; ] } }} 添加.prettierrc文件在项目根目录下 123456{ &quot;semi&quot;: true, &quot;singleQuote&quot;: false, &quot;tabWidth&quot;: 2, &quot;trailingComma&quot;: &quot;es5&quot;} AntdLayout在src下创建目录Layout和index.tsx和index.css /Layout/index.css 12345678910111213141516171819202122.demoLogoVertical { height: 32px; background: #fff; border-radius: 6px; margin: 16px;}.userCenterParent { float: right; padding-right: 10px;}.userCenterChild { height: 32px; font-size: 14px; color: #fff;}.userCenterChildUserAvatar { padding-right: 4px;} /Layout/index.tsx 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697import React, { useState } from &quot;react&quot;;import { LogoutOutlined, MenuFoldOutlined, MenuUnfoldOutlined, NotificationOutlined, UploadOutlined, UserOutlined, VideoCameraOutlined,} from &quot;@ant-design/icons&quot;;import { Layout, Menu, Button, theme, Row, Space, Badge } from &quot;antd&quot;;import styles from &quot;@/Layout/Layout.module.css&quot;;const { Header, Sider, Content } = Layout;const AdminLayout: React.FC = () =&gt; { const [collapsed, setCollapsed] = useState(false); const { token } = theme.useToken(); return ( &lt;Layout style={{ minHeight: &quot;100vh&quot; }}&gt; &lt;Sider trigger={null} collapsible collapsed={collapsed}&gt; &lt;div className={styles.demoLogoVertical} /&gt; &lt;Menu theme=&quot;dark&quot; mode=&quot;inline&quot; style={{ backgroundColor: &quot;#42465f&quot; }} defaultSelectedKeys={[&quot;1&quot;]} items={[ { key: &quot;1&quot;, icon: &lt;UserOutlined /&gt;, label: &quot;nav 1&quot;, }, { key: &quot;2&quot;, icon: &lt;VideoCameraOutlined /&gt;, label: &quot;nav 2&quot;, }, { key: &quot;3&quot;, icon: &lt;UploadOutlined /&gt;, label: &quot;nav 3&quot;, }, ]} /&gt; &lt;/Sider&gt; &lt;Layout&gt; &lt;Header style={{ padding: 0 }}&gt; &lt;Button type=&quot;text&quot; icon={collapsed ? &lt;MenuUnfoldOutlined /&gt; : &lt;MenuFoldOutlined /&gt;} onClick={() =&gt; setCollapsed(!collapsed)} style={{ fontSize: &quot;16px&quot;, width: 64, height: 64, color: &quot;#FFFFFF&quot;, }} /&gt; &lt;Space className={styles.userCenterParent}&gt; &lt;Button icon={&lt;UserOutlined /&gt;} className={`${styles.userCenterChild} ${styles.userCenterChildUserAvatar}`} type=&quot;text&quot; &gt; admin &lt;/Button&gt; &lt;Badge count={5} size=&quot;small&quot; offset={[5, 5]}&gt; &lt;NotificationOutlined className={`${styles.userCenterChild}`} /&gt; &lt;/Badge&gt; &lt;Button type=&quot;text&quot; className={styles.userCenterChild} onClick={() =&gt; {}} icon={&lt;LogoutOutlined /&gt;} /&gt; &lt;/Space&gt; &lt;/Header&gt; &lt;Content style={{ margin: &quot;24px 16px&quot;, padding: 24, minHeight: 280, }} &gt; Content &lt;/Content&gt; &lt;/Layout&gt; &lt;/Layout&gt; );};export default AdminLayout; @/src/App.tsx 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import React, { useState } from &quot;react&quot;;import { MenuFoldOutlined, MenuUnfoldOutlined, UploadOutlined, UserOutlined, VideoCameraOutlined,} from &quot;@ant-design/icons&quot;;import { Layout, Menu, Button, theme } from &quot;antd&quot;;import &quot;./index.css&quot;;const { Header, Sider, Content } = Layout;const AdminLayout: React.FC = () =&gt; { const [collapsed, setCollapsed] = useState(false); const { token } = theme.useToken(); return ( &lt;Layout style={{ minHeight: &quot;100vh&quot; }}&gt; &lt;Sider trigger={null} collapsible collapsed={collapsed}&gt; &lt;div className=&quot;demo-logo-vertical&quot; /&gt; &lt;Menu theme=&quot;dark&quot; mode=&quot;inline&quot; style={{ backgroundColor: &quot;#42465f&quot; }} defaultSelectedKeys={[&quot;1&quot;]} items={[ { key: &quot;1&quot;, icon: &lt;UserOutlined /&gt;, label: &quot;nav 1&quot;, }, { key: &quot;2&quot;, icon: &lt;VideoCameraOutlined /&gt;, label: &quot;nav 2&quot;, }, { key: &quot;3&quot;, icon: &lt;UploadOutlined /&gt;, label: &quot;nav 3&quot;, }, ]} /&gt; &lt;/Sider&gt; &lt;Layout&gt; &lt;Header style={{ padding: 0 }}&gt; &lt;Button type=&quot;text&quot; icon={collapsed ? &lt;MenuUnfoldOutlined /&gt; : &lt;MenuFoldOutlined /&gt;} onClick={() =&gt; setCollapsed(!collapsed)} style={{ fontSize: &quot;16px&quot;, width: 64, height: 64, color: &quot;#FFFFFF&quot;, }} /&gt; 123123aaa &lt;/Header&gt; &lt;Content style={{ margin: &quot;24px 16px&quot;, padding: 24, minHeight: 280, }} &gt; Content &lt;/Content&gt; &lt;/Layout&gt; &lt;/Layout&gt; );};export default AdminLayout;","link":"/2024/01/08/React%E4%B8%AD%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0/"},{"title":"LeeCode刷题","text":"LeeCode刷题记录 88. 合并两个有序数组给你两个按 非递减顺序 排列的整数数组&nbsp;nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。 请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。 注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。 &nbsp; 示例 1： 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 输出：[1,2,2,3,5,6] 解释：需要合并 [1,2,3] 和 [2,5,6] 。 合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。 示例 2： 输入：nums1 = [1], m = 1, nums2 = [], n = 0 输出：[1] 解释：需要合并 [1] 和 [] 。 合并结果是 [1] 。 示例 3： 输入：nums1 = [0], m = 0, nums2 = [1], n = 1 输出：[1] 解释：需要合并的数组是 [] 和 [1] 。 合并结果是 [1] 。 注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。 &nbsp; 提示： nums1.length == m + n nums2.length == n 0 &lt;= m, n &lt;= 200 1 &lt;= m + n &lt;= 200 -109 &lt;= nums1[i], nums2[j] &lt;= 109 &nbsp; 进阶：你可以设计实现一个时间复杂度为 O(m + n) 的算法解决此问题吗？ 关键词解释非递减顺序 一组元素排序的方式以非递减的顺序排列，即元素值从左到右逐渐增加，允许相邻值相等。 [1,2,2,3,4,5,5,6] 递减顺序 一组元素排序的方式以递减的顺序排列，即元素值从左到右逐渐减少，允许相邻值相等。 [6,5,5,4,3,2,2,1] 分析 Result最终有效长度为 m + n 两个是非递减顺序，所有result的-1位一定是最大的 倒序进行比较","link":"/2024/01/10/LeeCode%E5%88%B7%E9%A2%98/"},{"title":"Go-2.Go镜像配置","text":"在 Go 语言的上下文中，”镜像”通常指的是 Go 模块的镜像，这是模块源的一个备份或者代理。由于网络原因，特别是在中国大陆，直接访问 Go 的官方模块仓库 goproxy.io 或者版本控制系统如 GitHub 可能会受到限制或速度较慢。因此，使用镜像服务可以加速模块的下载并提高构建项目的效率。 Go 1.13 及以上版本引入了模块代理（module proxy）功能，允许开发者配置 Go 命令使用指定的模块代理服务器（即镜像）来下载依赖。中国大陆的开发者通常会配置国内的 Go 模块镜像服务，如七牛云的 goproxy.cn 或者中国科技大学的 goproxy.io。 配置 Go 模块镜像要配置 Go 模块镜像，你可以设置 GOPROXY 环境变量。以下是在不同操作系统上设置 GOPROXY 的方法。 在 Bash (Linux 或 macOS) 中配置：打开你的终端，然后运行以下命令： 1export GOPROXY=https://goproxy.cn,direct 如果你想要这个设置在重新启动终端后依然生效，你可以把它添加到你的 ~/.bashrc 或 ~/.bash_profile 文件中。 在 PowerShell (Windows) 中配置：打开 PowerShell，然后运行以下命令： 1$env:GOPROXY = &quot;https://goproxy.cn,direct&quot; 如果你想要这个设置在重新启动 PowerShell 后依然生效，你可以把它添加到你的 PowerShell 配置文件中。 使用 go 命令配置：另外，你也可以使用 go env 命令来永久设置环境变量： 1go env -w GOPROXY=https://goproxy.cn,direct 配置私有模块如果你在使用私有模块，可能还需要配置 GOPRIVATE 环境变量来跳过代理，直接从源获取。例如： 1export GOPRIVATE=*.corp.example.com 或者使用 go env 命令： 1go env -w GOPRIVATE=*.corp.example.com 配置 Go 模块校验和数据库Go 1.13 也引入了模块校验和数据库（the checksum database），你可以通过设置 GOSUMDB 环境变量来配置它。例如，要使用中国科技大学提供的校验和数据库服务： 1export GOSUMDB=sum.golang.google.cn 或者使用 go env 命令： 1go env -w GOSUMDB=sum.golang.google.cn GOSUMDB 是 Go 语言的一个环境变量，它指定了模块校验和数据库的位置。这个数据库用于确保模块代理提供的每个模块版本的内容都是一致的，这样可以增强安全性，防止中间人攻击或者模块内容的其他不当更改。 每当你使用 go get 或构建一个依赖模块的 Go 项目时，Go 工具链会计算下载的模块的校验和并与 GOSUMDB 指定的数据库中存储的校验和进行比对。如果校验和不匹配，Go 工具链会报告错误并停止构建过程。这确保了你使用的模块版本是被验证过的，且与模块作者发布的版本一致。 Go 团队运营了一个默认的模块校验和数据库 sum.golang.org，它为公开模块提供服务。但是在某些地区，如中国大陆，由于网络问题，直接访问这个服务可能会很慢或不可靠。因此，Go 开发者可能会选择一个更靠近或者服务更好的校验和数据库。例如，中国科技大学提供的 sum.golang.google.cn 就是一个受欢迎的选择。 你可以通过设置 GOSUMDB 环境变量来指定使用哪个校验和数据库。如果你不希望使用任何校验和数据库，也可以将 GOSUMDB 设置为 off，但这样会降低安全保障。","link":"/2024/01/02/Go-2.Go%E9%95%9C%E5%83%8F%E9%85%8D%E7%BD%AE/"},{"title":"Go-1.GoEnv安装","text":"在这篇文章中，我们将介绍如何使用 goenv 工具来搭建一个可管理多个版本的 Go 语言开发环境。 前言goenv 是一个类似于 rbenv 和 pyenv 的版本管理工具，它可以让你在同一台机器上安装和管理多个版本的 Go 语言环境。 基本要求在开始安装 goenv 之前，确保你的系统中已经安装了基本的构建工具如 git、curl、gcc 等。 安装步骤 克隆 goenv 仓库到 ~/.goenv： 1git clone https://github.com/syndbg/goenv.git ~/.goenv 配置环境变量： 将以下内容添加到你的 ~/.bash_profile 或 ~/.zshrc 文件中： 123export GOENV_ROOT=&quot;$HOME/.goenv&quot;export PATH=&quot;$GOENV_ROOT/bin:$PATH&quot;eval &quot;$(goenv init -)&quot; 重新启动你的终端或者执行以下命令来应用更改： 123source ~/.bash_profile# 或者source ~/.zshrc 使用 goenv安装 Go 版本使用 goenv 安装新的 Go 版本非常简单： 12goenv install -l # 列出所有可安装的版本goenv install 1.15.6 # 安装特定版本，例如 1.15.6 设置全局 Go 版本设置全局默认的 Go 版本： 1goenv global 1.15.6 项目局部版本你可以为每个项目设置一个局部的 Go 版本： 12cd your_project_directorygoenv local 1.15.6 常见问题 如何更新 goenv？ 你可以通过以下命令来更新 goenv： 1cd $GOENV_ROOT &amp;&amp; git pull 如何卸载 goenv 中的 Go 版本？ 使用 goenv uninstall 命令： 1goenv uninstall 1.15.6 总结现在你已经知道如何使用 goenv 来管理你的 Go 语言版本了。这将使得在不同项目之间切换 Go 版本变得简单，也有助于保持你的开发环境的整洁。","link":"/2024/01/02/Go-1.GoEnv%E5%AE%89%E8%A3%85/"},{"title":"接口自动化测试","text":"使用Python + Pytest + Requests实现的REST风格接口自动化测试框架 环境搭建项目初始化1234567# 创建项目与环境mkdir api-testcd api-test# 创建虚拟创建pyenv virutalenv 3.11.3 api-testpyenv local api-testpip install -r requirement -i https://pypi.tuna.tsinghua.edu.cn/simple requirements.txt依赖1234567891011121314151617181920212223242526272829303132333435363738394041#requirements.txtaiohttp==3.8.4aiosignal==1.3.1allure-pytest==2.11.1allure-python-commons==2.11.1async-timeout==4.0.2attrs==22.1.0black==23.3.0certifi==2022.9.24charset-normalizer==2.1.1click==8.1.3exceptiongroup==1.1.0execnet==2.0.2filelock==3.12.2frozenlist==1.3.3idna==3.4iniconfig==1.1.1jsonpath==0.82jsonschema==4.17.0loguru==0.6.0multidict==6.0.4mypy-extensions==1.0.0packaging==23.1pathspec==0.11.1platformdirs==3.6.0pluggy==1.0.0PyJWT==2.7.0pyparsing==3.0.9pyrsistent==0.19.2pytest==7.2.0pytest-ordering==0.6pytest-rerunfailures==10.3pytest-xdist==3.3.1PyYAML==6.0requests==2.28.1requests-toolbelt==0.10.1six==1.16.0tomli==2.0.1urllib3==1.26.12yarl==1.9.2 项目结构12345678910111213141516.├── Readme.md├── Resource├── core # 核心文件├── fx_module # 测试业务模块，类似PO模式的Page类├── jenkins_job # docker快速部署├── jenkins_jobs.py # jenkins构建后执行文件，用于处理报告├── local_state # 存储一些持久化数据报告├── log # 日志存储├── main.py # 驱动Jenkins执行pytest文件├── manual_run.py # 手动执行文件├── pytest.ini # pytest配置文件├── report # 报告├── requirements.txt # 依赖├── test_cases # 测试用例└── utils # 工具类，如加密方法，yaml读取 实现Core目录重写requests请求，添加业务逻辑12mkdir corevim basic_request.py 12345678910# coding=utf-8&quot;&quot;&quot;@author: linaa@file: basic_request.py@time: 2022/10/9 09:30@description: &quot;&quot;&quot;import json, requestsfrom core.config import Config","link":"/2024/01/02/%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"},{"title":"测试平台bladerunner","text":"使用FastAPI + Sqlalchemy做后端并以 React + antd + zustand完成一个测试平台中后台管理应用。 FastAPI后端简介FastAPI 是一个用于构建 API 的现代、快速（高性能）的 web 框架，专为在 Python 中构建 RESTful API 而设计。。 FastAPI 使用 Python 3.8+ 并基于标准的 Python 类型提示。 FastAPI 建立在 Starlette 和 Pydantic 之上，利用类型提示进行数据处理，并自动生成API文档。 功能- [ ] 日志结构 - [ ] 数据库连接和基类创建 - [ ] 数据库迁移与升级 - [ ] ORM数据序列化 - [ ] Pydantic和异常 - [ ] 自定义异常响应码 - [ ] 基于JWT的用户鉴权系统 - [ ] 定时任务 安装 安装pyenv虚拟环境，参考pyenv的安装与使用 pip的安装 1pip install fastapi pyjwt sqlalchem aiomysql uvicorn alembic pydantic 项目结构设计1234567891011121314151617181920212223242526272829.├── app # 项目主包│ ├── __init__.py│ ├── base # 基础类，包含mysql连接,base_mixin表基类和Config文件│ ├── exceptions # 统一错误码，用于异常响应拦截│ ├── handler # 序列化、鉴权等方法│ ├── middleware # 中间件│ ├── mock # sql文件，用于初始化数据│ ├── models # 业务表│ ├── register # 路由注册、表注册等│ ├── router # 路由信息│ ├── users │ ├── services # 业务逻辑│ ├── users # 鉴权中心│ ├── schema # 数据校验│ ├── crud # 增删改查│ ├── users.py # 鉴权服务│ ├── tests # 单元测试│ └── utils # 工具类(时间戳转化、日志等)├── docker_build # Docker快速部署├── env_config # env文件│ ├── dev.docker.env│ └── dev.env├── logs # 日志存放│ ├── gunicorn.err│ └── gunicorn.log├── requirements.txt└── uvicorn_runner.py # 运行文件 API使用技巧依赖项Depends的使用简介编程中的「依赖注入」是声明代码（本文中为路径操作函数 ）运行所需的，或要使用的「依赖」的一种方式。 然后，由系统（本文中为 FastAPI）负责执行任意需要的逻辑，为代码提供这些依赖（「注入」依赖项）。 依赖注入常用于以下场景： 共享业务逻辑（复用相同的代码逻辑） 共享数据库连接 实现安全、验证、角色权限 等…… 上述场景均可以使用依赖注入，将代码重复最小化。 Depends-分页函数的形式作为依赖性 使用函数参数和返回值作为FastAPI的Depends依赖性，从而实现减少GET Api分页代码 12345678910111213141516from fastapi import Depends, FastAPI, Queryapp = FastAPI()def query_page_limit(page_number: int = Query(1), page_size: int = Query(10)): &quot;&quot;&quot;分页参数校验&quot;&quot;&quot; if page_number &lt;= 0: page_number = 1 if page_size &lt;= 0: page_size = 10 return {&quot;page_number&quot;: page_number, &quot;page_size&quot;: page_size}@app.get(&quot;/list&quot;)async def lists(page_size: dict = Depends(query_page_limit)): print(page_size) # out: {'page_size': 20, 'page_number': 1} return page_size 类的形式作为依赖项 在函数形式的依赖项上进行升级，从而使得编辑器的补全能力加强 12345678910111213141516171819from fastapi import Depends, FastAPI, Queryapp = FastAPI()class QueryPaginate: def __init__(self, page_number: int = Query(1), page_size: int = Query(20)): self.page_number = page_number self.page_size = page_size@app.get(&quot;/list&quot;)async def lists(page_size: QueryPaginate = Depends(QueryPaginate)): print(page_size) # out: {'page_size': 20, 'page_number': 1} return page_size# 快捷方法, page_size指定类型QueryPaginate类，然后Depends不传入任何参数@app.get(&quot;/list&quot;)async def lists(page_size: QueryPaginate = Depends()): print(page_size) # out: {'page_size': 20, 'page_number': 1} return page_size 路径操作装饰器里的依赖项 指在@app.get()这种路径操作装饰器里运行依赖项 使用场景: 运行多个依赖函数\\类并且在路由下的方法里不需要获取依赖函数\\类的值。比方说: 仅校验Token是否过期。 12345678910111213141516from fastapi import Depends, FastAPI, Header, HTTPExceptionapp = FastAPI()async def verify_token(x_token: str = Header()): if x_token != &quot;fake-super-secret-token&quot;: raise HTTPException(status_code=400, detail=&quot;X-Token header invalid&quot;)async def verify_key(x_key: str = Header()): if x_key != &quot;fake-super-secret-key&quot;: raise HTTPException(status_code=400, detail=&quot;X-Key header invalid&quot;) return x_key@app.get(&quot;/items/&quot;, dependencies=[Depends(verify_token), Depends(verify_key)])async def read_items(): return [{&quot;item&quot;: &quot;Foo&quot;}, {&quot;item&quot;: &quot;Bar&quot;}] 全局依赖项 直接在FastAPI实例里添加依赖项 1234567891011121314151617181920from fastapi import Depends, FastAPI, Header, HTTPExceptionasync def verify_token(x_token: str = Header()): if x_token != &quot;fake-super-secret-token&quot;: raise HTTPException(status_code=400, detail=&quot;X-Token header invalid&quot;)async def verify_key(x_key: str = Header()): if x_key != &quot;fake-super-secret-key&quot;: raise HTTPException(status_code=400, detail=&quot;X-Key header invalid&quot;) return x_keyapp = FastAPI(dependencies=[Depends(verify_token), Depends(verify_key)])@app.get(&quot;/items/&quot;)async def read_items(): return [{&quot;item&quot;: &quot;Portal Gun&quot;}, {&quot;item&quot;: &quot;Plumbus&quot;}]@app.get(&quot;/users/&quot;)async def read_users(): return [{&quot;username&quot;: &quot;Rick&quot;}, {&quot;username&quot;: &quot;Morty&quot;}] React + Zustand","link":"/2024/01/02/%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0bladerunner/"},{"title":"Github配置","text":"Git 是一个分布式版本控制系统，它广泛用于协作开发、源代码管理以及版本控制。以下是 Git 的一些基本概念和常用操作。 Windows安装 下载 Git 安装程序： 访问 Git 官方网站，在首页找到 “Download” 按钮，然后选择 Windows 平台并下载安装程序。 运行安装程序： 打开下载的安装程序，并按照提示进行安装。在安装过程中，你可以选择安装选项，建议使用默认设置。 验证安装： 打开命令提示符（Command Prompt）或 PowerShell，运行以下命令验证 Git 是否安装成功： 1git --version Mac安装 使用 Homebrew 安装 Git： 打开终端，并运行以下命令安装 Homebrew（如果尚未安装），然后使用 Homebrew 安装 Git： 12/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;brew install git 验证安装： 在终端运行以下命令验证 Git 是否安装成功： 1git --version Ubuntu安装 使用 APT 安装 Git： 打开终端，并运行以下命令安装 Git： 12sudo apt updatesudo apt install git 验证安装： 在终端运行以下命令验证 Git 是否安装成功： 1git --version Git配置默认全局配置 设置用户名和邮箱： 在终端或命令提示符中运行以下命令，将 &lt;Your-Name&gt; 和 &lt;Your-Email&gt; 替换为你的 GitHub 用户名和邮箱： 12git config --global user.name &quot;Your-Name&quot;git config --global user.email &quot;Your-Email&quot; 生成 SSH 密钥： 运行以下命令生成 SSH 密钥： 1ssh-keygen -t rsa -b 4096 -C &quot;Your-Email&quot; 按照提示操作，使用默认选项。生成的密钥默认存储在 ~/.ssh/id_rsa。 添加 SSH 密钥到 SSH 代理： 运行以下命令添加 SSH 密钥到 SSH 代理： 12eval &quot;$(ssh-agent -s)&quot;ssh-add ~/.ssh/id_rsa 将 SSH 密钥添加到 GitHub： 复制 SSH 密钥的内容，然后在 GitHub 上的设置中添加新的 SSH 密钥。 验证 SSH 连接： 运行以下命令验证 SSH 连接是否成功： 1ssh -T git@github.com 确认是否询问是否要连接 GitHub。 多账号配置​ 当我们需要为一台电脑配置多个账号时需使用多账号配置避免出现git pull或者push时的权限问题。以下的例子使用a1,a2来区分账号1和账号2，可以根据个人需要进行修改，保证可读性。 生成ssh密钥 12ssh-keygen -t rsa -b 4096 -C &quot;Your-Account1-Email&quot; # 存储为~/.ssh/id_rsa_a1ssh-keygen -t rsa -b 4096 -C &quot;Your-Account2-Email&quot; # 存储为~/.ssh/id_rsa_a2 在.ssh目录下创建config文件 1234# cd到.ssh目录cd ~/.ssh# 创建config文件vim config 编辑config文件 123456789Host github-a1HostName github.comUser Your-Account1-EmailIdentityFile ~/.ssh/id_rsa_a1Host github-a2HostName github.comUser Your-Account2-EmailIdentityFile ~/.ssh/id_rsa_a2 测试 123ssh -T git@github-a1ssh -T git@github-a2# O: Hi botplayer0! You've successfully authenticated, but GitHub does not provide shell access 多账号下仓库关联修改以多账号配置的情况下，在git本地仓库中需要修改以下的点。 1234567891011# 进入仓库cd any-github-repository# 配置当前目录下的仓库username和emailgit config --local user.email &quot;Your-Account1-Email&quot;git config --local user.name &quot;Your-Account1-name&quot;# 查看git remote地址git remote -v# 如无信息，则关联远程仓库git remote add origin git@github-a1:${git-user-name}/any-github-repository.git# 有则修改关联git remote set-url origin git@github-a1:${git-user-name}/any-github-repository.git","link":"/2024/01/02/Github%E9%85%8D%E7%BD%AE/"},{"title":"pyenv的安装与使用","text":"pyenv 是一个用于管理 Python 版本的工具。它允许你轻松地在同一台机器上安装和切换多个 Python 版本。通过使用 pyenv，你可以在不同项目之间使用不同的 Python 版本，而无需全局更改系统的 Python 版本。 常见的指令pyenv install &lt;version&gt;：安装指定版本的 Python。 pyenv global &lt;version&gt;：设置全局 Python 版本。 pyenv local &lt;version&gt;：为当前目录设置局部 Python 版本。 pyenv versions：列出已安装的 Python 版本。 pyenv rehash：在安装或删除 Python 版本后，更新可执行文件的哈希值。 安装Windows系统参考链接: GitHub - pyenv-win/pyenv-win: pyenv for Windows. pyenv is a simple python version management tool. It lets you easily switch between multiple versions of Python. It’s simple, unobtrusive, and follows the UNIX tradition of single-purpose tools that do one thing well. PowerShell安装方式 打开PowerShell终端运行指令 1Invoke-WebRequest -UseBasicParsing -Uri &quot;&lt;https://raw.githubusercontent.com/pyenv-win/pyenv-win/master/pyenv-win/install-pyenv-win.ps1&gt;&quot; -OutFile &quot;./install-pyenv-win.ps1&quot;; &amp;&quot;./install-pyenv-win.ps1&quot; 重启终端 运行指令并验证是否生效 12pyenv version// OUT: &lt;version&gt; (set by \\\\path\\\\to\\\\.pyenv\\\\pyenv-win\\\\.python-version) ZIP包安装方式 下载ZIP包: https://github.com/pyenv-win/pyenv-win/archive/master.zip 创建目录: %USERPROFILE%/.pyenv 方法一: 终端命令行输入mkdir %USERPROFILE%/.pyenv 方法二: C:\\Users\\xxx下创建.pyenv文件 将zip包解压至该目录下 添加系统环境变量 Ubuntu 使用以下命令安装 Pyenv 的依赖项： 1234sudo apt-get updatesudo apt-get install -y build-essential libssl-dev zlib1g-dev libbz2-dev \\\\ libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev \\\\ xz-utils tk-dev libffi-dev liblzma-dev python3-openssl git 使用以下命令在用户主目录下克隆 Pyenv 存储库： 1git clone &lt;https://github.com/pyenv/pyenv.git&gt; ~/.pyen 将 Pyenv 添加到 bashrc 或 zshrc 文件中： 12345echo 'export PYENV_ROOT=&quot;$HOME/.pyenv&quot;' &gt;&gt; ~/.bashrcecho 'export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;' &gt;&gt; ~/.bashrcecho 'eval &quot;$(pyenv init --path)&quot;' &gt;&gt; ~/.bashrcecho 'eval &quot;$(pyenv virtualenv-init -)&quot;' &gt;&gt; ~/.bashrcsource ~/.bashrc 完成后，你可以使用 pyenv 命令来管理 Python 版本。 MacOS 使用 Homebrew 安装 Pyenv： 1brew install pyenv 将 Pyenv 初始化添加到 shell 配置文件： 12echo 'eval &quot;$(pyenv init --path)&quot;' &gt;&gt; ~/.zshrc # 如果使用 Zshecho 'eval &quot;$(pyenv init --path)&quot;' &gt;&gt; ~/.bash_profile # 如果使用 Bash 重新加载 shell 配置文件： 123bashCopy codesource ~/.zshrc # 如果使用 Zshsource ~/.bash_profile # 如果使用 Bash 完成后，你可以使用 pyenv 命令来管理 Python 版本。","link":"/2024/01/02/pyenv%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"PlayWright","slug":"PlayWright","link":"/tags/PlayWright/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/tags/Ubuntu/"},{"name":"系统环境","slug":"系统环境","link":"/tags/%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"LeeCode","slug":"LeeCode","link":"/tags/LeeCode/"},{"name":"Golang","slug":"Golang","link":"/tags/Golang/"},{"name":"接口自动化","slug":"接口自动化","link":"/tags/%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"pytest","slug":"pytest","link":"/tags/pytest/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"FastAPI","slug":"FastAPI","link":"/tags/FastAPI/"},{"name":"sqlalchemy","slug":"sqlalchemy","link":"/tags/sqlalchemy/"},{"name":"pyenv","slug":"pyenv","link":"/tags/pyenv/"}],"categories":[{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"网站推荐","slug":"网站推荐","link":"/categories/%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90/"},{"name":"程序日常","slug":"程序日常","link":"/categories/%E7%A8%8B%E5%BA%8F%E6%97%A5%E5%B8%B8/"},{"name":"React","slug":"React","link":"/categories/React/"},{"name":"LeeCode","slug":"LeeCode","link":"/categories/LeeCode/"},{"name":"Golang","slug":"Golang","link":"/categories/Golang/"},{"name":"测试平台","slug":"Python/测试平台","link":"/categories/Python/%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0/"}],"pages":[]}